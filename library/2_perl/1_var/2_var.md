Переменные, массивы и ссылки.
ПЕРЕМЕННЫЕ
Переменные объявляются с помощью следующих ключевых слов:
* my <переменная>; - локальная переменная;
* our <переменная>; - глобальная переменная.

Имя переменной сопровождается уточняющим символом (оператором разыменования ссылки), определяющим структуру этой переменной, а именно:
* $ - скалярные данные;
* @ - массив;
* % - хэш-таблица (ассоциативный массив);
* & - функция.
Эти префиксы определяют контекст выборки (разыменования ссылки) значения переменной, сообщая Perl требуемую структуру данных, а тот, в свою очередь, пытается привести значение к этой структуре.

В качестве имени переменной может выступать любая последовательность латинских букв, цифр и знака подчеркивания, начинающаяся с буквы или знака подчеркивания. Регистр в именах переменных учитывается.

Для инициализации переменной используется запись:

  <переменная> = <значение>;

Инициализировать переменные можно в месте их объявления.

Для получения значения переменной используется один из операторов разыменования ссылки, приведенных выше. Perl обращается к соответствующей области памяти для получения значения переменной:

  my $c = $a + $b;

В данном случае имя переменной заменяется хранимым в ней значением. Если переменная еще не была инициализирована, значением ее является пустая строка, но не следует использовать не инициализированные переменные, это может приводить к ошибке компиляции.

МАССИВЫ
Массивы представляют собой плоский список скаляров. Для инициализации массива используется запись вида:

  @<переменная> = (<значение>, ...);

Здесь каждое значение является отдельным элементом массива (индексация начинается с нуля).

Для доступа к элементу массива используется запись вида:

  $<переменная>[<индекс>];

При этом запись заменяется значением элемента под данным индексом. Обратите внимание что используется префикс $ вместо @, это означает что мы хотим получить скалярный тип, то есть значение конкретной ячейки, а не массив. Так как массивы в Perl это список скаляров, доступ к каждому элементу должен сопровождаться символом $.

Значение элементу массива можно задать следующим образом:

  $<переменная>[<индекс>]=<значение>;

Как и раньше, для доступа к элементу массива используется префикс $, который объясняет Perl, что мы работает со скаляром.

Ниже приведен пример объявления и использования простого массива дней недели:

  my @week=('Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс');
  $week[0]='Вс';
  $week[6]='Пн';
  print $week[0]; # Ответом будет 'Вс'.

Если передать массив в качестве элемента при инициализации другого массива, это приведет к их конкатенации:

  <массивA> = (<значениеA>, ...);
  <массивB> = (<значениеB>, @<массивA>);
  print <массивB>; # Ответом будет <значениеB><значениеA> - то есть конкатенация значений массивов.

Это вызвано тем, что в качестве элемента не может выступать массив (разве что ссылка на него), а только скаляр, следовательно Perl объединяет массивы для решения этой задачи.

Если присвоить одному массиву другой, то принимающий массив получит те же значения, что и передающий:

  <массивA> = (<значениеA>);
  <массивB> = (<значениеB>);
  <массивB> = <массивA>;
  print <массивB>; # Ответом будет <значениеA> - то есть элементы "массиваA"

Это означает, что Perl может разбивать массив на переменные следующим образом:

  (<переменнаяA>, ...) = <массив>;

В этом случае каждой переменной будет присвоено соответствующее значение элемента массива. Ниже приведен пример этого:

  my @arr = (1,2,3);
  my ($x, $y) = @arr;
  print $y; # Ответом будет 2 - то есть второй элемент массива.

Для создания многомерных массивов можно использовать ссылки на другие массивы в качестве элементов. Ниже приведен пример многомерного массива и его использование:

  my $arr = [1,2,[3,4]];
  print $arr->[2]->[0]; # В данном случае мы используем оператор ->, рассматриваемый ниже, для разыменования ссылок и доступа к первому элементу вложенного массива.

ХЭШ-ТАБЛИЦЫ
Хэш-таблица представляют собой плоский список скаляров, отличающийся от массива тем, что в качестве индексов используются строки (ключи). Для инициализации хэш-таблицы используется запись вида:

  %<переменная> = (<ключ> => <значение>, ...);

Для доступа к элементу хэш-таблицы используется запись вида:

  $<переменная>{<ключ>};

При этом запись заменяется значением элемента под данным ключем. Обратите внимание что используется префикс $ вместо %, это означает что мы хотим получить скалярный тип, то есть значение конкретной ячейки, а не хэш-таблицу. Так как хэш-таблица в Perl это список скаляров, доступ к каждому элементу должен сопровождаться символом $.

Значение элементу хэш-таблицы можно задать следующим образом:

  $<переменная>{<ключ>}=<значение>;

Как и раньше, для доступа к элементу хэш-таблицы используется префикс $, который объясняет Perl, что мы работает со скаляром.

Ниже приведен пример объявления и использования простой хэш-таблицы дней недели:

  my %week = ('Пн' => 1, 'Вт' => 2, 'Ср' => 3, 'Чт' => 4, 'Пт' => 5, 'Сб' => 6, 'Вс' => 7);
  $week{'Вс'} = 0;
  print $week{'Вс'}; # Ответом будет 0.

Если передать хэш-таблицу в качестве элемента при инициализации другой хэш-таблицы, это приведет к их конкатенации:

  <хэшA> = (<ключA> => <значениеA>, ...);
  <хэшB> = (<ключB> => <значениеB>, %<хэшA>);
  print <хэшB>; # Ответом будет <ключB><значениеB><ключA><значениеA> - то есть конкатенация значений хэш-таблиц.

Это вызвано тем, что в качестве элемента не может выступать хэш-таблица (разве что ссылка на нее), а только скаляр, следовательно Perl объединяет хэш-таблицы для решения этой задачи.

Если присвоить одной хэш-таблице другую, то принимающая получит те же значения, что и передающая:

  <хэшA> = (<ключA> => <значениеA>, ...);
  <хэшB> = (<ключA> => <значениеB>, ...);
  <хэшB> = <хэшA>;
  print <хэшB>; # Ответом будет <ключA><значениеA> - то есть элементы "хэшаA"

Для создания многомерных хэш-таблиц можно использовать ссылки на другие хэш-таблицы в качестве элементов. Ниже приведен пример многомерной хэш-таблицы и ее использование:

  my $hash = {'a' => 1, 'b' => {'c' => 2}};
  print $hash->{'b'}->{'c'}; # В данном случае мы используем оператор ->, рассматриваемый ниже, для разыменования ссылок и доступа к первому элементу вложенной хэш-таблицы.

ССЫЛКИ
Для получения ссылки на переменную достаточно использовать оператор взятия адреса \:

  my $a = 1;
  my $b = \$a;

Разыменование ссылки производится аналогично разыменованию переменной, с помощью соответствующего префикса $, @, % или &:

  $c = $$b;

Здесь первый оператор $ (ближе к b) возвращает переменную $a, а второй оператор $ возвращает хранящееся в ней значение.

Аналогичным образом выполняется доступ к другим структурам, важно лишь помнить, что последовать разыменования с права на лево:

  my @arr = (1,2,3); # Массив.
  my $b = \@arr; # Взятие адреса (ссылки) массива.
  print @$b; # Последовательное получение переменной @a (оператор $), а затем его значения (оператор @)

Ссылки на массивы и хэш-таблицы могут быть созданы при их инициализации, для этого используются операторы [] и {}:

  my $arr = [1,2,3]; # Ссылка на массив.
  my $hash = {'a' => 1, 'b' => 2}; # Ссылка на хэш-таблицу.

Аналогично может быть создана ссылка на скаляр при его инициализации, для этого необходимо указать \ перед оператором my или our:

  \my $var; # Создание ссылки на скаляр.

Для прохода по ссылке можно использовать оператор ->:

  my $arr = [1,2,3];
  print $arr->[0]; # Ответом будет 1 - оператор -> выполнил разыменование ссылки и вернул массив, к первому элементу которого мы и обратились.

Особенностью Perl является то, нельзя получить ссылку на возвращаемое функцией значение путем использования оператора \:

  my $a = \getArr();

В данном случае $a будет хранить последний элемент возвращаемого массива. Для решения этой задачи необходимо заключить функцию в квадратные скобки, что создаст ссылку на возвращаемый массив (или фигурные скобки для создания ссылки на хэш-таблицу):

  my $a = [getArr()];
  my $b = {getHash()};
